package poker

import (
	"context"
	"fmt"
	"log"

	"github.com/mterwill/jira-poker/pkg/jira"
	"github.com/mterwill/jira-poker/pkg/slack"
)

const (
	maxIssues        = 10
	defaultConfigURL = "https://github.com/mterwill/jira-poker"
)

// Config is a 1:1 JIRA:Slack integration
type Config struct {
	PrefixMessage   string `yaml:"prefix_message"`
	SlackWebhookURL string `yaml:"slack_webhook_url"`
	JQL             string `yaml:"jql"`
	SkipSendEmpty   bool   `yaml:"skip_send_empty"`
}

// Poker stores global JIRA config
type Poker struct {
	jiraServer   string
	jiraUsername string
	jiraPassword string
	configURL    string
}

// New creates a new Poker
func New(jiraServer, jiraUsername, jiraPassword, configURL string) *Poker {
	if configURL == "" {
		configURL = defaultConfigURL
	}

	return &Poker{jiraServer, jiraUsername, jiraPassword, configURL}
}

// Run finds JIRA issues matching a given JQL and post the result to Slack.
func (p *Poker) Run(ctx context.Context, c *Config) error {
	j := jira.New(p.jiraServer, p.jiraUsername, p.jiraPassword)
	resp, err := j.FindIssues(ctx, c.JQL)
	if err != nil {
		return err
	}

	if len(resp.Issues) == 0 && c.SkipSendEmpty {
		log.Printf("Found no results for JQL `%s` and Config.SkipSendEmpty is on.", c.JQL)
		return nil
	}

	var blocks []*slack.Block

	blocks = append(blocks, &slack.Block{
		Type: slack.BlockTypeSection,
		Text: &slack.Text{
			Type: slack.BlockTextTypeMarkdown,
			Text: c.PrefixMessage,
		},
	})

	if len(resp.Issues) == 0 {
		blocks = append(blocks, &slack.Block{
			Type: slack.BlockTypeSection,
			Text: &slack.Text{
				Type: slack.BlockTextTypeMarkdown,
				Text: "_No issues found matching filter._",
			},
		})
	} else {
		for i, issue := range resp.Issues {
			if i > maxIssues {
				break
			}

			blocks = append(blocks, &slack.Block{
				Type: slack.BlockTypeSection,
				Text: &slack.Text{
					Type: slack.BlockTextTypeMarkdown,
					Text: fmt.Sprintf(
						"â€¢ *<%s|%s>* %s (status: `%s`, assignee: `%s`)",
						j.LinkForIssue(&issue),
						issue.Key,
						issue.Fields.Summary,
						issue.Fields.Status.Name,
						issue.Assignee(),
					),
				},
			})
		}
	}

	if resp.Total > maxIssues {
		blocks = append(blocks, &slack.Block{
			Type: slack.BlockTypeSection,
			Text: &slack.Text{
				Type: slack.BlockTextTypeMarkdown,
				Text: fmt.Sprintf("_showing %d of %d total results._", maxIssues, resp.Total),
			},
		})
	}

	blocks = append(blocks, &slack.Block{
		Type: slack.BlockTypeDivider,
	})

	blocks = append(blocks, &slack.Block{
		Type: slack.BlockTypeSection,
		Text: &slack.Text{
			Type: slack.BlockTextTypeMarkdown,
			Text: fmt.Sprintf("This message was generated by <%s|jira-poker> using the JQL: ```%s```", p.configURL, c.JQL),
		},
	})

	s := slack.New(c.SlackWebhookURL)
	err = s.PostMessage(ctx, &slack.Message{
		Blocks: blocks,
	})

	if err != nil {
		return err
	}

	return nil
}
